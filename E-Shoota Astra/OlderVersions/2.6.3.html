<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>E-Shoota Astra: Chaos Edition V2.6 (Final Fix)</title>
    <style>
        /* --- LAYOUT & STRUCTURE --- */
        body { margin: 0; padding: 0; background-color: #050505; overflow: hidden; font-family: 'Courier New', Courier, monospace; color: #fff; touch-action: none; display: flex; width: 100vw; height: 100vh; }
        
        /* SIDEBARS */
        #ai-wrapper { width: 0; background: #0a0f14; border-right: 1px solid #0ff; overflow: hidden; transition: width 0.3s ease-in-out; position: relative; display: flex; flex-direction: column; flex-shrink: 0; z-index: 10; }
        #rival-wrapper { width: 0; background: #140a0a; border-left: 1px solid #f00; overflow: hidden; transition: width 0.3s ease-in-out; position: relative; display: flex; flex-direction: column; flex-shrink: 0; z-index: 10; }
        .sidebar-content { width: 380px; padding: 20px; box-sizing: border-box; height: 100%; overflow-y: auto; }

        /* GAME CONTAINER */
        #game-container { flex: 1; position: relative; background: #000; overflow: hidden; min-width: 0; min-height: 0; display: flex; align-items: center; justify-content: center; }
        canvas { display: block; width: 100%; height: 100%; }

        /* --- UI ELEMENTS --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 5; }
        
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; padding: 15px; font-weight: bold; text-shadow: 0 0 5px #0f0; color: #0f0; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); pointer-events: auto; }
        .hud-group { display: flex; flex-direction: column; gap: 5px; }
        .hp-container { position: relative; width: 70px; height: 70px; display: flex; align-items: center; justify-content: center; }
        #hp-pie { width: 100%; height: 100%; border-radius: 50%; background: conic-gradient(#f00 0deg, #f00 360deg, #333 0deg); box-shadow: 0 0 10px #f00; border: 2px solid #fff; }
        .hp-text-overlay { position: absolute; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #000; width: 50px; height: 50px; border-radius: 50%; font-size: 14px; color: #fff; }
        
        .score-container { text-align: right; }
        .xp-mini-track { width: 120px; height: 5px; background: #002; border: 1px solid #0cf; margin-top: 4px; position: relative; margin-left: auto; border-radius: 2px; }
        .xp-mini-fill { height: 100%; background: #0cf; width: 0%; box-shadow: 0 0 8px #0cf; transition: width 0.2s; }
        .xp-mini-label { position: absolute; left: -25px; top: -4px; font-size: 9px; color: #0cf; font-weight: bold; }

        .level-progress-container { width: 200px; height: 10px; background: #300; border: 1px solid #f55; margin-top: 5px; position: relative; border-radius: 4px; }
        .level-progress-fill { height: 100%; background: #f00; width: 0%; transition: width 0.2s; }
        .level-progress-text { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 8px; color: #fff; text-shadow: 1px 1px 0 #000; }
        
        #pause-btn { background: rgba(0, 20, 0, 0.8); border: 2px solid #0f0; color: #0f0; width: 40px; height: 40px; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center; border-radius: 5px; pointer-events: auto; }
        
        .screen-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(10, 10, 10, 0.95); padding: 30px; border: 2px solid #0f0; border-radius: 15px; pointer-events: auto; box-shadow: 0 0 30px rgba(0, 255, 0, 0.1); min-width: 300px; max-width: 90%; z-index: 20; }
        #start-screen { background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(3px); box-shadow: 0 0 50px rgba(0, 255, 0, 0.2); border: 3px solid #0f0; }
        
        #watch-btn { position: absolute; bottom: 30px; right: 30px; width: 50px; height: 50px; border: 2px solid #555; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; color: #aaa; background: rgba(0,0,0,0.6); transition: 0.3s; z-index: 50; pointer-events: auto; }
        #watch-btn:hover { color: #fff; border-color: #0f0; background: #000; transform: scale(1.1); box-shadow: 0 0 15px #0f0; }
        #watch-overlay { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 15; pointer-events: auto; cursor: pointer; }
        #watch-hint { position: absolute; bottom: 20px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 12px; pointer-events: none; text-transform: uppercase; letter-spacing: 2px; animation: blink 2s infinite; }
        @keyframes blink { 0%,100%{opacity:0.3} 50%{opacity:0.8} }

        h1 { margin: 0 0 20px 0; color: #0f0; text-transform: uppercase; letter-spacing: 3px; text-shadow: 0 0 10px #0f0; }
        button.btn { background: rgba(0, 20, 0, 0.5); border: 2px solid #0f0; color: #0f0; padding: 12px 24px; font-size: 16px; font-family: inherit; cursor: pointer; margin-top: 15px; text-transform: uppercase; transition: 0.2s; width: 100%; }
        button.btn:hover { background: #0f0; color: #000; box-shadow: 0 0 15px #0f0; }
        button.ad-btn { border-color: #f90; color: #f90; display: flex; align-items: center; justify-content: center; gap: 10px; margin-top: 20px; font-weight: bold; }
        
        .upgrade-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 20px; }
        .upgrade-card { border: 2px solid #fff; padding: 15px; cursor: pointer; background: rgba(0, 0, 0, 0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100px; }
        .upgrade-card:hover { transform: scale(1.05); filter: brightness(1.2); }
        .rarity-common { border-color: #0f0; color: #0f0; } .rarity-uncommon { border-color: #00f; color: #00f; } .rarity-rare { border-color: #d0f; color: #d0f; } .rarity-legendary { border-color: #f00; color: #f00; border-width: 3px; }
        
        #debug-menu { position: absolute; top: 10%; left: 10%; background: rgba(0,0,0,0.9); border: 2px solid #fff; padding: 20px; z-index: 100; display: none; color: #fff; font-family: monospace; pointer-events: auto; max-height: 80vh; overflow-y: auto; }
        .debug-btn { display: block; width: 100%; background: #333; border: 1px solid #777; color: #fff; padding: 5px; margin: 5px 0; cursor: pointer; text-align: left; }
        
        #boss-warning { display: none; position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); color: #f00; font-size: 40px; font-weight: bold; text-shadow: 0 0 20px #f00; animation: pulse 0.5s infinite; pointer-events: none; white-space: nowrap; text-align: center; z-index: 30; }
        #duel-text { display: none; position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 60px; font-weight: bold; text-shadow: 0 0 30px #0ff; z-index: 35; pointer-events: none; white-space: nowrap; text-align: center; }
        @keyframes pulse { 0% { opacity: 1; transform: translate(-50%,-50%) scale(1); } 50% { opacity: 0.5; transform: translate(-50%,-50%) scale(1.1); } 100% { opacity: 1; transform: translate(-50%,-50%) scale(1); } }
        
        .hidden { display: none !important; }
        
        #mobile-controls { display: none; position: absolute; bottom: 0; left: 0; width: 100%; height: 180px; pointer-events: auto; padding: 20px; box-sizing: border-box; justify-content: space-between; align-items: flex-end; }
        .dpad-cluster { display: flex; flex-direction: column; align-items: center; gap: 5px; padding-bottom: 10px; }
        .dpad-row { display: flex; gap: 20px; }
        .t-btn { width: 65px; height: 65px; border-radius: 50%; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); color: #fff; display: flex; align-items: center; justify-content: center; font-size: 24px; user-select: none; backdrop-filter: blur(2px); }
        .t-btn:active { background: rgba(0,255,0,0.3); border-color: #0f0; }
        .attack-area { display: flex; align-items: flex-end; padding-bottom: 10px; }
        .t-fire { width: 80px; height: 80px; border-color: rgba(255,50,50,0.5); background: rgba(255,50,50,0.1); font-size: 30px; }
        .t-fire:active { background: rgba(255,50,50,0.4); }
        @media (max-width: 1024px) { #mobile-controls { display: flex; } }
        
        #pause-time { font-size: 24px; color: #fff; margin-bottom: 15px; border-bottom: 1px solid #555; padding-bottom: 10px; display: block; }
        .pause-actions { display: flex; gap: 10px; width: 100%; margin-top: 10px; }
        
        /* SIDEBARS */
        #ai-sidebar h3 { color: #0ff; margin-top: 0; border-bottom: 1px solid #0ff; padding-bottom: 10px; }
        #rival-sidebar h3 { color: #f00; margin-top: 0; border-bottom: 1px solid #f00; padding-bottom: 10px; }
        .chart-container { margin: 10px 0; border: 1px solid #333; background: #000; position: relative; width: 100%; box-sizing:border-box; }
        canvas.chart-canvas { width: 100%; height: 100%; display: block; }
        #ai-log, #rival-log { height: 120px; overflow-y: auto; background: #111; border: 1px solid #444; color: #0f0; font-family: monospace; font-size: 10px; padding: 5px; margin-top: 10px; }
        #rival-log { color: #f55; border-color: #844; }
        textarea.data-io { width: 100%; height: 40px; background: #222; border: 1px solid #555; color: #0f0; font-family: monospace; font-size: 10px; margin-top: 10px; resize: none; }
        .sidebar-actions { display: flex; gap: 5px; margin-top: 5px; }
        .sidebar-btn { flex: 1; background: #333; border: 1px solid #777; color: #fff; cursor: pointer; font-size: 10px; padding: 4px; }
        
        .monitor-row { display: flex; justify-content: space-between; margin-bottom: 5px; color: #ccc; font-size: 11px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .monitor-val { font-weight: bold; color: #f55; }
    </style>
</head>
<body>

    <!-- LEFT: PLAYER AI -->
    <div id="ai-wrapper">
        <div id="ai-sidebar-content" class="sidebar-content">
            <div id="ai-sidebar">
                <h3>NEURAL ANALYTICS v3.1</h3>
                <div style="font-size:10px; color:#aaa; margin-bottom:5px;">LIVE DECISION FEED</div>
                <div class="chart-container" style="height:60px;"><canvas id="ai-live-feed" class="chart-canvas" width="340" height="60"></canvas></div>
                <div style="font-size:9px; display:flex; justify-content:space-between; color:#aaa; margin-bottom:10px;"><span><span style="color:#f55">AGGRESSION</span> / <span style="color:#55f">CAUTION</span></span><span id="ai-state-text">IDLE</span></div>
                <div style="font-size:10px; color:#0ff; border-bottom:1px solid #333; margin-top:10px;">THREAT SOURCES</div>
                <div class="chart-container" style="height:100px;"><canvas id="chart-pie" class="chart-canvas" width="340" height="100"></canvas></div>
                <div style="font-size:10px; color:#f0f; border-bottom:1px solid #333; margin-top:10px;">BEHAVIOR WEIGHTS</div>
                <div class="chart-container" style="height:120px;"><canvas id="chart-radar" class="chart-canvas" width="340" height="120"></canvas></div>
                <div style="font-size:10px; color:#ff0; border-bottom:1px solid #333; margin-top:10px;">KILL STATS</div>
                <div class="chart-container" style="height:80px;"><canvas id="chart-bar" class="chart-canvas" width="340" height="80"></canvas></div>
                <h4 style="color:#fff; margin: 15px 0 5px 0; border-bottom: 1px solid #555; font-size:12px;">GEN: <span id="ai-gen">1</span> | HIGH: <span id="ai-best-score">0</span></h4>
                <div id="ai-log"></div>
                <h4 style="color:#0f0; margin: 15px 0 5px 0; border-bottom: 1px solid #555; font-size:12px;">DNA I/O</h4>
                <textarea id="ai-data-io" class="data-io" placeholder="AI Data String..."></textarea>
                <div class="sidebar-actions">
                    <button class="sidebar-btn" onclick="aiCore.exportData()">Copy DNA</button>
                    <button class="sidebar-btn" onclick="aiCore.importData()">Import DNA</button>
                    <button class="sidebar-btn" style="color:#f55" onclick="aiCore.resetData()">WIPE MEMORY</button>
                </div>
            </div>
        </div>
    </div>

    <!-- MIDDLE: GAME -->
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="ui-layer">
            <div class="hud-top" id="main-hud">
                <div class="hud-group">
                    <div class="hp-container">
                        <div id="hp-pie"></div>
                        <div class="hp-text-overlay"><div style="font-size: 10px; color: #aaa;">HP</div><span id="txt-hp">100</span></div>
                    </div>
                </div>
                <div class="hud-group" style="align-items: center;">
                    <div style="font-size: 24px; line-height: 1;">LVL <span id="txt-lvl">1</span></div>
                    <div class="level-progress-container"><div class="level-progress-fill" id="lvl-prog-fill"></div><div class="level-progress-text" id="lvl-prog-text">Next Level</div></div>
                    <div style="font-size: 12px; color: #aaa; min-height: 15px; margin-top:5px;" id="mode-text"></div>
                </div>
                <div class="hud-group" style="align-items: flex-end;">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="score-container">
                            <div>SCORE <span id="txt-score">0</span></div>
                            <div class="xp-mini-track"><div class="xp-mini-fill" id="xp-bar-mini"></div><div class="xp-mini-label">XP</div></div>
                        </div>
                        <button id="pause-btn" onclick="game.togglePause()">‚è∏</button>
                    </div>
                </div>
            </div>
            <div id="boss-warning">‚ö†Ô∏è BOSS INCOMING ‚ö†Ô∏è<br><span id="boss-name" style="font-size: 20px; color: #fff;"></span></div>
            <div id="duel-text" style="display:none;">DUEL START</div>
            
            <!-- Debug Menu -->
            <div id="debug-menu">
                <h3>DEBUG CONSOLE</h3>
                <button class="debug-btn" onclick="debug.toggleAuto()">Auto-Pilot (AI): <span id="dbg-auto">OFF</span></button>
                <button class="debug-btn" onclick="debug.toggleSpawning()">Enemy Spawning: <span id="dbg-spawn">ON</span></button>
                <button class="debug-btn" style="color:#0ff" onclick="debug.toggleSidebar()">Toggle Player AI (Left)</button>
                <button class="debug-btn" style="color:#f55" onclick="debug.toggleRivalSidebar()">Toggle Rival AI (Right)</button>
                <button class="debug-btn" onclick="debug.toggleMusic()">Music: <span id="dbg-music">ON</span></button>
                <button class="debug-btn" onclick="debug.toggleGod()">Toggle God Mode: <span id="dbg-god">OFF</span></button>
                <button class="debug-btn" onclick="debug.toggleInsta()">Instant Kill: <span id="dbg-insta">OFF</span></button>
                <button class="debug-btn" onclick="debug.skipLevel()">Skip Level (Next Wave)</button>
                <button class="debug-btn" style="color:#f90" onclick="debug.skipTo20()">‚è© Skip to LVL 20 (Rival)</button>
                <button class="debug-btn" style="color:#f00" onclick="debug.forceRival()">‚öîÔ∏è Force Random Rival</button>
                <button class="debug-btn" onclick="debug.killAll()">Kill All Enemies</button>
                <button class="debug-btn" onclick="debug.skipToBoss()">Skip to Boss</button>
                <button class="debug-btn" style="color: #ff0" onclick="debug.skipToJob()">Skip to JOB APPLICATION</button>
                <button class="debug-btn" style="color:#f55" onclick="debug.close()">Close (+)</button>
            </div>

            <div id="watch-btn" onclick="game.toggleWatchMode(true)" title="Watch Demo Play">üëÅÔ∏è</div>
            <div id="watch-overlay" onclick="game.toggleWatchMode(false)">
                <div id="watch-hint">Click anywhere to return</div>
            </div>

            <div id="start-screen" class="screen-overlay">
                <h1 style="font-size: 40px;">E-Shoota Astra<br><span class="subtitle">Chaos Edition V2.6</span></h1>
                <button class="btn" onclick="game.startGameplay()">START</button>
            </div>

            <div id="pause-screen" class="screen-overlay hidden">
                <h1>PAUSED</h1>
                <div id="pause-time">Run Time: 00:00</div>
                <button class="btn" onclick="game.togglePause()">Resume Mission</button>
                <div class="pause-actions">
                    <button class="btn" style="background: #400; border-color:#f55;" onclick="game.restartRun()">‚Üª Restart</button>
                    <button class="btn" style="background: #044; border-color:#0ff;" onclick="game.resetToMenu()">üè† Main Menu</button>
                </div>
            </div>

            <div id="upgrade-screen" class="screen-overlay hidden">
                <h2 style="color:#fff">SYSTEM UPGRADE</h2>
                <div class="upgrade-grid" id="upgrade-list"></div>
            </div>

            <div id="game-over-screen" class="screen-overlay hidden">
                <h1 style="color: #f55; font-size: 40px;" id="game-over-title">You Suck :)</h1>
                <p style="font-size: 18px;">Score: <span id="final-score">0</span> | Level: <span id="final-level">0</span></p>
                <button class="btn ad-btn" onclick="fakeAd()"><span>üì∫</span> Watch Ad for Extra Life?</button>
                <button class="btn" onclick="game.resetToMenu()" style="margin-top: 30px; border-color: #fff; color: #fff;">Return to Base</button>
            </div>

            <div id="mobile-controls">
                <div class="dpad-cluster">
                    <div class="t-btn" id="btn-u">‚ñ≤</div>
                    <div class="dpad-row"><div class="t-btn" id="btn-l">‚óÑ</div><div class="t-btn" id="btn-r">‚ñ∫</div></div>
                </div>
                <div class="attack-area"><div class="t-btn t-fire" id="btn-f">‚óè</div></div>
            </div>
        </div>
    </div>

    <!-- RIGHT: RIVAL AI -->
    <div id="rival-wrapper">
        <div id="rival-sidebar-content" class="sidebar-content">
            <div id="rival-sidebar">
                <h3>RIVAL CORTEX v1.1</h3>
                <div class="monitor-row"><span>Target Status</span><span class="monitor-val" id="r-target">OFFLINE</span></div>
                <div class="monitor-row"><span>Target Dist</span><span class="monitor-val" id="r-dist">0</span></div>
                <div class="monitor-row"><span>Tactical Mode</span><span class="monitor-val" id="r-mode">OBSERVE</span></div>
                
                <div id="rival-learning" style="margin-top:10px; border-top:1px solid #400; padding-top:5px;">
                    <div style="font-size:10px; color:#f00;">LIVE COMBAT METRICS</div>
                    <div class="monitor-row"><span>Player DPS:</span><span class="monitor-val" id="r-speed">0</span></div>
                    <div class="monitor-row"><span>Target Accuracy:</span><span class="monitor-val" id="r-fire">0%</span></div>
                    <div class="monitor-row"><span>Evasion Rate:</span><span class="monitor-val" id="r-evade">0%</span></div>
                    <div class="monitor-row"><span>Counter-Strat:</span><span class="monitor-val" id="r-pred">ANALYZING</span></div>
                </div>

                <div style="font-size:10px; color:#f55; border-bottom:1px solid #533; margin-top:15px;">VISUAL CORTEX</div>
                <div class="chart-container" style="height:120px;"><canvas id="rival-vision" class="chart-canvas" width="340" height="120"></canvas></div>
                <h4 style="color:#f00; margin: 15px 0 5px 0; border-bottom: 1px solid #844; font-size:12px;">THOUGHT STREAM</h4>
                <div id="rival-log"></div>
            </div>
        </div>
    </div>

<script>
(function() {
    const aiCore = {
        data: { weights: { avoid: 8.0, attack: 1.0, bombPriority: 25.0, safeDist: 150 }, stats: { runs: 0, highest: 1, gen: 0, bestScore: 0 }, kills: {'asteroid':0, 'enemy':0, 'boss':0}, damageTaken: {'bullet':0, 'contact':0, 'env':0}, bestWeights: null },
        history: [], maxHistory: 50, panelOpen: false,
        init() { 
            try { 
                const s = localStorage.getItem('astra_ai_v3'); 
                if(s) { 
                    const p = JSON.parse(s); 
                    if(p && p.weights) this.data = p; 
                    else throw new Error("Corrupt Data");
                    if(!this.data.bestWeights) this.data.bestWeights = {...this.data.weights}; 
                } else { 
                    this.data.bestWeights = {...this.data.weights}; 
                } 
            } catch(e) { 
                console.log("AI Data Reset: " + e);
                localStorage.removeItem('astra_ai_v3');
            } 
        },
        recordRun(lvl, killer, score) { this.data.stats.runs++; this.data.stats.gen++; if(score > this.data.stats.bestScore) { this.data.stats.bestScore = score; this.data.stats.highest = lvl; this.data.bestWeights = {...this.data.weights}; this.log(`NEW BEST! ${Math.floor(score)}`); } else { this.log(`Fail ${Math.floor(score)}. Mutating.`); this.data.weights = {...this.data.bestWeights}; this.data.weights.avoid += (Math.random()-0.5)*2; this.data.weights.attack += (Math.random()-0.5)*0.5; } this.save(); this.updateUI(); },
        recordDamage(src) { if(!this.data.damageTaken) this.data.damageTaken={}; this.data.damageTaken[src] = (this.data.damageTaken[src]||0)+1; },
        recordKill(t) { if(!this.data.kills) this.data.kills={}; this.data.kills[t] = (this.data.kills[t]||0)+1; },
        save() { localStorage.setItem('astra_ai_v3', JSON.stringify(this.data)); },
        resetData() { localStorage.removeItem('astra_ai_v3'); location.reload(); },
        exportData() { document.getElementById('ai-data-io').value = btoa(JSON.stringify(this.data)); document.getElementById('ai-data-io').select(); document.execCommand('copy'); alert("Copied!"); },
        importData() { try { this.data = JSON.parse(atob(document.getElementById('ai-data-io').value)); this.save(); this.updateUI(); alert("Imported."); } catch(e) { alert("Bad Data"); } },
        log(msg) { const l = document.getElementById('ai-log'); if(!l)return; const d = new Date(); l.innerHTML = `<div class="log-entry"><span style="color:#777">[${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}]</span> ${msg}</div>` + l.innerHTML; },
        trackLive(a, f, s) { this.history.push({a:Math.min(100,a), f:Math.min(100,f)}); if(this.history.length>this.maxHistory) this.history.shift(); if(this.panelOpen) { document.getElementById('ai-state-text').innerText = s; this.drawCharts(); } },
        drawCharts() { this.drawLine(); this.drawPie(); this.drawRadar(); this.drawBar(); },
        drawLine() { const c=document.getElementById('ai-live-feed').getContext('2d'); c.fillStyle='#000'; c.fillRect(0,0,340,60); c.lineWidth=2; c.beginPath(); c.strokeStyle='#55f'; this.history.forEach((h,i)=>{let x=(i/this.maxHistory)*340, y=60-(h.f/100)*60; i?c.lineTo(x,y):c.moveTo(x,y)}); c.stroke(); c.beginPath(); c.strokeStyle='#f55'; this.history.forEach((h,i)=>{let x=(i/this.maxHistory)*340, y=60-(h.a/100)*60; i?c.lineTo(x,y):c.moveTo(x,y)}); c.stroke(); },
        drawPie() { const c=document.getElementById('chart-pie').getContext('2d'); const d=this.data.damageTaken||{}; const t=Object.values(d).reduce((a,b)=>a+b,0)||1; let s=0, cols={'bullet':'#f55','contact':'#fa0','env':'#55f'}; c.clearRect(0,0,340,100); for(let k in d) { let v=(d[k]/t)*Math.PI*2; c.beginPath(); c.moveTo(50,50); c.arc(50,50,40,s,s+v); c.fillStyle=cols[k]||'#ccc'; c.fill(); s+=v; } },
        drawRadar() { const c=document.getElementById('chart-radar').getContext('2d'); c.clearRect(0,0,340,120); const w=this.data.weights; const s=[{v:Math.min(1,w.attack/3),l:'AGG'},{v:Math.min(1,w.avoid/15),l:'FEAR'},{v:Math.min(1,w.safeDist/300),l:'DIST'},{v:0.5,l:'OBJ'},{v:0.5,l:'SPD'}]; c.strokeStyle='#444'; c.beginPath(); for(let i=0;i<5;i++){ let a=(Math.PI*2*i)/5-Math.PI/2; c.lineTo(170+Math.cos(a)*50, 60+Math.sin(a)*50); } c.closePath(); c.stroke(); c.strokeStyle='#0ff'; c.beginPath(); for(let i=0;i<5;i++){ let a=(Math.PI*2*i)/5-Math.PI/2; let d=s[i].v*50; i?c.lineTo(170+Math.cos(a)*d, 60+Math.sin(a)*d):c.moveTo(170+Math.cos(a)*d, 60+Math.sin(a)*d); } c.stroke(); },
        drawBar() { const c=document.getElementById('chart-bar').getContext('2d'); c.clearRect(0,0,340,80); let x=10, d=this.data.kills||{}, m=Math.max(1,Math.max(...Object.values(d))), cols={'asteroid':'#888','enemy':'#f80','boss':'#f0f'}; for(let k in d) { let h=(d[k]/m)*60; c.fillStyle=cols[k]||'#fff'; c.fillRect(x, 80-h-15, 30, h); c.fillText(d[k],x,80); x+=40; } },
        updateUI() { if(!this.panelOpen)return; document.getElementById('ai-gen').innerText = this.data.stats.gen; document.getElementById('ai-best-score').innerText = Math.floor(this.data.stats.bestScore); }
    };

    const rivalBrain = {
        panelOpen: false, lastLog: 0, samples: 0,
        playerDPS: 0, playerEntropy: 0, lastPx: 0, lastPy: 0, shotsFired: 0, shotsHit: 0,
        observe(player) {
            if(!player) return;
            this.samples++;
            let distMoved = Math.hypot(player.x - this.lastPx, player.y - this.lastPy);
            this.playerEntropy = (this.playerEntropy * 0.9) + (distMoved * 0.1);
            this.lastPx = player.x; this.lastPy = player.y;
            this.playerDPS = player.stats.dmg * (60/player.stats.fireRate) * player.stats.multi;
            
            if (this.panelOpen) {
                const isActive = game.entities.rival && !game.entities.rival.dead;
                document.getElementById('r-target').innerText = isActive ? "LOCKED ON" : "TRACKING...";
                document.getElementById('r-target').style.color = isActive ? "#f00" : "#555";
                document.getElementById('r-speed').innerText = Math.floor(this.playerDPS) + " dmg/s";
                let acc = this.samples > 0 ? Math.min(100, Math.floor((this.playerDPS / 10) + Math.random()*10)) : 0;
                document.getElementById('r-fire').innerText = acc + "%";
                let evade = Math.floor(this.playerEntropy * 2);
                document.getElementById('r-evade').innerText = Math.min(99, evade) + "%";

                let strat = "MATCH SPEED";
                if (this.playerEntropy > 10) strat = "PREDICT MOVEMENT";
                if (this.playerDPS > 200) strat = "EVASIVE MANEUVERS";
                document.getElementById('r-pred').innerText = strat;
                
                const c = document.getElementById('rival-vision').getContext('2d');
                c.fillStyle = '#050505'; c.fillRect(0,0,340,120);
                if (game.entities.ship) {
                    let px = (game.entities.ship.x / canvas.width) * 340;
                    let py = (game.entities.ship.y / canvas.height) * 120;
                    c.strokeStyle = '#0f0'; c.lineWidth = 2; c.strokeRect(px-5, py-5, 10, 10);
                    c.fillStyle = 'rgba(0, 255, 0, 0.2)'; c.fillRect(px-20, py, 40, 1); c.fillRect(px, py-20, 1, 40);
                }
                if (Date.now() - this.lastLog > 2000) {
                    let logMsg = "";
                    if (this.playerDPS > 150) logMsg = `WARN: High Player DPS (${Math.floor(this.playerDPS)})`;
                    else if (this.playerEntropy > 15) logMsg = "Target erratic. Engaging prediction.";
                    else if (game.entities.rival) logMsg = "Executing combat algorithm...";
                    else logMsg = "Scanning hostile parameters...";
                    this.log(logMsg);
                    this.lastLog = Date.now();
                }
            }
        },
        update(rival, player) {
            if (this.samples % 60 === 0) {
                 rival.stats.spd = Math.max(1.5, player.stats.spd * 1.1);
                 rival.stats.fireRate = Math.max(5, player.stats.fireRate * 0.9);
                 rival.stats.multi = Math.max(1, player.stats.multi);
            }
            if (!this.panelOpen) return;
            const distToP = Math.hypot(rival.x - player.x, rival.y - player.y);
            document.getElementById('r-dist').innerText = Math.floor(distToP);
            const c = document.getElementById('rival-vision').getContext('2d');
            let rx = (rival.x / canvas.width) * 340; let ry = (rival.y / canvas.height) * 120;
            c.fillStyle = '#f00'; c.beginPath(); c.arc(rx, ry, 4, 0, 7); c.fill();
        },
        log(msg) { const l = document.getElementById('rival-log'); if(!l)return; const d = new Date(); l.innerHTML = `<div class="log-entry">[${d.getSeconds()}] ${msg}</div>` + l.innerHTML; }
    };

    const images = { jobBoss: new Image() }; images.jobBoss.src = 'Assets/jobapplication.jpg';
    
    // SFX (Preloaded for responsiveness)
    const sfx = { 
        shoot: new Audio("data:audio/wav;base64,UklGRjQBAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YREBAACAg4OEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7/AAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4CBgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7/AAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4CBgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7/AA=="), 
        bruh: new Audio('https://www.myinstants.com/media/sounds/movie_1.mp3'), 
        pop: new Audio('https://www.myinstants.com/media/sounds/pop-sound-effect.mp3'), 
        sike: new Audio('https://www.myinstants.com/media/sounds/sike-sound-effect.mp3') 
    };
    try{sfx.shoot.volume=0.1;}catch(e){}

    // --- OPTIMIZED MUSIC SYSTEM v2.2 (Fixed for Level 20 & Debug) ---
    const MusicSystem = {
        bgm: new Audio(),
        pauseTrack: new Audio('OST/Locked In.mp3'),
        isMuted: false,
        currentTag: null, // 'menu', 'normal', 'boss', 'rival'
        tracks: {
            menu: 'OST/AstraExpress.wav',
            job: 'OST/Shadow Circuit (High Quality).wav',
            rival: 'OST/Hell Yeah.mp3',
            normal: [
                'OST/Normal_Level_Music/Paper Cuts.mp3', 
                'OST/Normal_Level_Music/Deadlines.mp3', 
                'OST/Normal_Level_Music/GoTime.mp3', 
                'OST/Normal_Level_Music/Slice of Panic.wav'
            ]
        },

        init() {
            this.bgm.volume = 0.4;
            this.pauseTrack.loop = true;
            this.pauseTrack.volume = 0.4;
            
            // Handle Playlist Logic
            this.bgm.onended = () => {
                // IMPORTANT: Explicitly enforce looping for Rival and Job modes to prevent falling back to normal tracks
                if (this.currentTag === 'rival') {
                    this.bgm.currentTime = 0;
                    this.bgm.play().catch(e=>{});
                } else if (this.currentTag === 'job') {
                    this.bgm.currentTime = 0;
                    this.bgm.play().catch(e=>{});
                } else if (this.currentTag === 'normal') {
                    this.playNormal(true); // Shuffle next track
                }
            };
        },

        play(tag, force = false) {
            if (this.isMuted) return;
            if (this.currentTag === tag && !force) return;
            
            this.currentTag = tag;
            let src = '';

            if (tag === 'normal') {
                src = this.tracks.normal[Math.floor(Math.random() * this.tracks.normal.length)];
            } else {
                src = this.tracks[tag];
            }

            if (!src) return;

            // Force stop and load new src
            this.bgm.pause();
            this.bgm.src = src;
            
            // We handle looping logic manually in onended to be safer
            this.bgm.loop = false; 
            
            const playPromise = this.bgm.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => { console.warn("Audio playback prevented:", error); });
            }
        },

        playMenu() { this.play('menu'); },
        playJob() { this.play('job'); },
        playRival() { this.play('rival', true); }, // Force update
        playNormal(force = false) { this.play('normal', force); },

        togglePause(isPaused) {
            if (this.isMuted) return;
            if (isPaused) {
                this.bgm.pause();
                this.pauseTrack.currentTime = 0;
                this.pauseTrack.play().catch(e=>{});
            } else {
                this.pauseTrack.pause();
                this.bgm.play().catch(e=>{});
            }
        },

        stopAll() {
            this.bgm.pause();
            this.pauseTrack.pause();
        },

        toggleMute() {
            this.isMuted = !this.isMuted;
            if (this.isMuted) this.stopAll();
            else {
                if (game.state === 'paused') this.pauseTrack.play();
                else this.bgm.play();
            }
            return this.isMuted;
        }
    };
    document.addEventListener('click', function initAudio() { MusicSystem.init(); document.removeEventListener('click', initAudio); }, {once:true});

    const CONST = { SHIP_SIZE: 15, FRICTION: 0.96, THRUST: 0.3, BASE_HP: 100, BOSS_TYPES: ["Jax", "Henry", "Larry", "Bob", "Steve"] };
    const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
    const ui = { hp: document.getElementById('txt-hp'), hpPie: document.getElementById('hp-pie'), lvl: document.getElementById('txt-lvl'), score: document.getElementById('txt-score'), xpBar: document.getElementById('xp-bar'), progBar: document.getElementById('lvl-prog-fill'), progText: document.getElementById('lvl-prog-text'), mode: document.getElementById('mode-text'), debug: document.getElementById('debug-menu'), hudMain: document.getElementById('main-hud'), pauseTime: document.getElementById('pause-time'), screens: { start: document.getElementById('start-screen'), pause: document.getElementById('pause-screen'), over: document.getElementById('game-over-screen'), upgrade: document.getElementById('upgrade-screen'), boss: document.getElementById('boss-warning'), duel: document.getElementById('duel-text') }, watchOverlay: document.getElementById('watch-overlay'), watchBtn: document.getElementById('watch-btn') };
    const keys = {};
    
    window.addEventListener('keydown', e => { if (e.key === '+' || e.code === 'NumpadAdd') debug.toggle(); if ((e.code === 'KeyP' || e.code === 'Escape') && (game.state === 'play' || game.state === 'paused')) game.togglePause(); keys[e.code] = true; if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) e.preventDefault(); });
    window.addEventListener('keyup', e => keys[e.code] = false);
    window.addEventListener('mousedown', e => { if(e.target.closest('#mobile-controls')) return; if(e.button === 0) keys['MouseLeft'] = true; });
    window.addEventListener('mouseup', e => { if(e.button === 0) keys['MouseLeft'] = false; });
    const touchBind = (id, key) => { const el = document.getElementById(id); if(el) { ['touchstart','mousedown'].forEach(e => el.addEventListener(e, (ev) => { ev.preventDefault(); ev.stopPropagation(); keys[key] = true; })); ['touchend','mouseup', 'mouseleave'].forEach(e => el.addEventListener(e, (ev) => { ev.preventDefault(); ev.stopPropagation(); keys[key] = false; })); } };
    const dist = (o1, o2) => Math.hypot(o1.x - o2.x, o1.y - o2.y);
    const rand = (min, max) => Math.random() * (max - min) + min;
    const checkCol = (c1, c2) => { if(!c1 || !c2) return false; return dist(c1, c2) < c1.r + c2.r; };

    class Entity { constructor(x, y, r, col) { this.x=x; this.y=y; this.r=r; this.color=col; this.vx=0; this.vy=0; this.dead=false; } update() { this.x+=this.vx; this.y+=this.vy; } draw() { ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,7); ctx.fill(); } }
    class Star { constructor() { this.x=Math.random()*canvas.width; this.y=Math.random()*canvas.height; this.size=Math.random()*2+0.5; this.speed=this.size*0.2; } update(vx, vy) { this.x-=vx*this.speed; this.y-=vy*this.speed; if(this.x<0)this.x=canvas.width; if(this.x>canvas.width)this.x=0; if(this.y<0)this.y=canvas.height; if(this.y>canvas.height)this.y=0; } draw() { ctx.fillStyle=`rgba(255,255,255,${Math.random()*0.5+0.3})`; ctx.fillRect(this.x,this.y,this.size,this.size); } }
    class Wall { constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; this.targetY = y; this.y = -h * 2; } update() { if(this.y < this.targetY) { this.y += 5; if(this.y > this.targetY) this.y = this.targetY; } } draw() { ctx.fillStyle = 'rgba(0, 255, 255, 0.2)'; ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2; ctx.fillRect(this.x, this.y, this.w, this.h); ctx.strokeRect(this.x, this.y, this.w, this.h); } }

    class Ship extends Entity {
        constructor() { super(canvas.width/2, canvas.height/2, CONST.SHIP_SIZE, '#fff'); this.a = -Math.PI/2; this.hp = CONST.BASE_HP; this.maxHp = CONST.BASE_HP; this.cd = 0; this.invuln = 0; this.stats = { spd: 1, fireRate: 15, dmg: 10, multi: 1, vamp: 0, shield: false }; }
        getSmartInputs() {
            const inputs = { up: false, left: false, right: false, fire: false }; const S = this; const weights = aiCore.data.weights; let vecX = 0, vecY = 0; let bomb = game.entities.bombs.find(b => !b.moving); let target = null; let minEDist = Infinity;
            if (game.entities.rival) { target = game.entities.rival; minEDist = dist(S, target); } else { game.entities.enemies.forEach(e => { let d = dist(S, e); if(d<minEDist){minEDist=d; target=e;} }); if (!target) game.entities.asteroids.forEach(a => { let d = dist(S, a); if(d<minEDist){minEDist=d; target=a;} }); }
            if (bomb && dist(S, bomb) > bomb.radius - 20) { vecX += (bomb.x - S.x) * weights.bombPriority; vecY += (bomb.y - S.y) * weights.bombPriority; } else if (target) { let predX = target.x + (target.vx || 0) * 10; let predY = target.y + (target.vy || 0) * 10; if (target instanceof Enemy || target instanceof Rival) { if (minEDist < weights.safeDist) { vecX -= (predX - S.x) * weights.avoid; vecY -= (predY - S.y) * weights.avoid; vecX += (S.y - predY); vecY -= (S.x - predX); } else { vecX += (predX - S.x) * weights.attack; vecY += (predY - S.y) * weights.attack; } } else { vecX += (predX - S.x) * weights.attack; vecY += (predY - S.y) * weights.attack; } }
            let avoidX = 0, avoidY = 0; [...game.entities.bullets.filter(b=>!b.isPlayer), ...game.entities.asteroids, ...game.entities.blackholes].forEach(t => { let d = dist(S, t); let safe = (t instanceof BlackHole) ? 350 : 120; if (d < safe) { let ax = S.x - t.x; let ay = S.y - t.y; let f = (safe - d) / safe; avoidX += ax * f; avoidY += ay * f; } }); vecX += avoidX * weights.avoid; vecY += avoidY * weights.avoid;
            game.entities.walls.forEach(w => { let forwardX = S.x + Math.cos(S.a) * 80; let forwardY = S.y + Math.sin(S.a) * 80; if (forwardX > w.x && forwardX < w.x + w.w && forwardY > w.y && forwardY < w.y + w.h) { vecX = Math.cos(S.a + Math.PI/2) * 100; vecY = Math.sin(S.a + Math.PI/2) * 100; } });
            if (debug.autoPilot) aiCore.trackLive(Math.sqrt(vecX*vecX+vecY*vecY), Math.sqrt(avoidX*avoidX+avoidY*avoidY)*10, bomb?"BOMB":(target?"COMBAT":"FARMING"));
            let desired = Math.atan2(vecY, vecX); if(isNaN(desired)) desired = S.a; let diff = desired - S.a; while(diff<=-Math.PI)diff+=Math.PI*2; while(diff>Math.PI)diff-=Math.PI*2; if(diff<-0.1) inputs.left=true; else if(diff>0.1) inputs.right=true; if(Math.abs(diff)<1) inputs.up=true; if (target) { let aim=Math.atan2(target.y-S.y, target.x-S.x); let ad=aim-S.a; while(ad<=-Math.PI)ad+=Math.PI*2; while(ad>Math.PI)ad-=Math.PI*2; if(Math.abs(ad)<0.5) inputs.fire=true; }
            return inputs;
        }
        getDemoInputs() { const inputs = { up: false, left: false, right: false, fire: false }; let target = null; let minDist = Infinity; [...game.entities.enemies, ...game.entities.asteroids].forEach(e => { let d = dist(this, e); if(d < minDist) { minDist = d; target = e; } }); if (target) { let ang = Math.atan2(target.y-this.y, target.x-this.x); let diff = ang - this.a; while(diff<=-Math.PI)diff+=Math.PI*2; while(diff>Math.PI)diff-=Math.PI*2; if(diff<-0.1)inputs.left=true; else if(diff>0.1)inputs.right=true; if(Math.abs(diff)<0.3)inputs.fire=true; if(minDist>200)inputs.up=true; } return inputs; }
        update(mode) {
            if(this.invuln > 0) this.invuln--; let kUp=false, kLeft=false, kRight=false, kFire=false; if (game.cutsceneState === 'rival_intro' && game.state === 'play') { return; }
            if (game.state === 'menu') { const ai = this.getDemoInputs(); kUp = ai.up; kLeft = ai.left; kRight = ai.right; kFire = ai.fire; } else if (debug.autoPilot) { const ai = this.getSmartInputs(); kUp = ai.up; kLeft = ai.left; kRight = ai.right; kFire = ai.fire; } else { kUp = keys.ArrowUp || keys.KeyW; kLeft = keys.ArrowLeft || keys.ArrowLeft || keys.KeyA; kRight = keys.ArrowRight || keys.KeyD; kFire = keys.Space || keys.Enter || keys.MouseLeft; }
            if (kLeft) this.a -= 0.1; if (kRight) this.a += 0.1; if (kUp) { this.vx += Math.cos(this.a) * CONST.THRUST * this.stats.spd; this.vy += Math.sin(this.a) * CONST.THRUST * this.stats.spd; if(Math.random()<0.5) game.entities.parts.push(new Particle(this.x - Math.cos(this.a)*this.r, this.y - Math.sin(this.a)*this.r, '#f55')); }
            this.vx *= CONST.FRICTION; this.vy *= CONST.FRICTION; 
            let nextX = this.x + this.vx; let nextY = this.y + this.vy; game.entities.walls.forEach(w => { if(nextX + this.r > w.x && nextX - this.r < w.x + w.w && nextY + this.r > w.y && nextY - this.r < w.y + w.h) { this.vx *= -0.5; this.vy *= -0.5; nextX = this.x; nextY = this.y; } }); this.x = nextX; this.y = nextY;
            if(this.x < -this.r) this.x = canvas.width + this.r; if(this.x > canvas.width + this.r) this.x = -this.r; if(this.y < -this.r) this.y = canvas.height + this.r; if(this.y > canvas.height + this.r) this.y = -this.r;
            if (kFire && this.cd <= 0) { this.cd = this.stats.fireRate; this.shoot(); } if (this.cd > 0) this.cd--;
        }
        shoot() { if (game.state === 'play' && sfx.shoot.currentTime > 0) sfx.shoot.currentTime = 0; if(game.state==='play') sfx.shoot.play().catch(e=>{}); const spread = 0.2; const noseX = this.x + Math.cos(this.a) * this.r; const noseY = this.y + Math.sin(this.a) * this.r; for(let i=0; i<this.stats.multi; i++) { let angle = this.a + (i - (this.stats.multi-1)/2) * spread; game.entities.bullets.push(new Bullet(noseX, noseY, angle, 15, this.stats.dmg, true)); } }
        draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.a); if(this.stats.shield) { ctx.strokeStyle = `rgba(0,255,255,${Math.abs(Math.sin(Date.now()/200))})`; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0,0,this.r + 10,0,7); ctx.stroke(); } ctx.strokeStyle = this.invuln > 0 ? '#f00' : '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.r, 0); ctx.lineTo(-this.r * 0.6, this.r * 0.7); ctx.lineTo(-this.r * 0.4, 0); ctx.lineTo(-this.r * 0.6, -this.r * 0.7); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-this.r * 0.6, this.r * 0.7); ctx.lineTo(-this.r, this.r); ctx.moveTo(-this.r * 0.6, -this.r * 0.7); ctx.lineTo(-this.r, -this.r); ctx.stroke(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.fill(); ctx.restore(); }
    }

    class Rival extends Ship {
        constructor(isRandom) { 
            super(); 
            this.x = canvas.width + 100; // Start off-screen RIGHT
            this.y = canvas.height / 2; 
            this.color = '#f00'; 
            this.isBoss = !isRandom; 
            const pStats = game.entities.ship ? game.entities.ship.stats : {spd:1, fireRate:15, dmg:10, multi:1};
            this.stats = { spd: pStats.spd * 1.1, fireRate: pStats.fireRate * 0.9, dmg: pStats.dmg, multi: pStats.multi, vamp: 0, shield: false };
            let pDPS = pStats.dmg * (60 / pStats.fireRate) * pStats.multi;
            let targetDuration = 45;
            this.hp = this.isBoss ? (pDPS * targetDuration) : (pDPS * 15);
            this.maxHp = this.hp;
            this.aiState = 'fight';
            this.fleeing = false; 
            this.scale = 1;
            this.dead = false;
            this.introTimer = 0; // Used for walking in
        }
        update() {
            // Intro Sequence: Walk in from Right
            if (this.isBoss && this.introTimer < 60) {
                this.introTimer++;
                this.x -= 2; // Move left
                this.a = Math.PI; // Face left
                return;
            }

            rivalBrain.update(this, game.entities.ship);
            if (this.fleeing) { this.x += Math.cos(this.a) * 30; this.y += Math.sin(this.a) * 30; game.entities.parts.push(new Particle(this.x, this.y, '#f00')); game.entities.parts.push(new Particle(this.x, this.y, '#fff')); if (this.x > canvas.width + 200 || this.x < -200 || this.y > canvas.height + 200 || this.y < -200) { this.dead = true; game.rivalActive = false; MusicSystem.playNormal(true); if(this.isBoss) { game.level = 21; game.spawnWave(); } else { game.addXP(10000); } } return; }
            if ((this.isBoss && this.hp < this.maxHp * 0.1) || (!this.isBoss && this.hp <= 0)) { this.fleeing = true; this.invuln = 9999; return; } if(this.invuln > 0) this.invuln--;
            
            const P = game.entities.ship;
            let vecX = P.x - this.x; let vecY = P.y - this.y;
            let avoidX=0, avoidY=0;
            [...game.entities.bullets.filter(b=>b.isPlayer), ...game.entities.enemies].forEach(obj => {
                let d = dist(this, obj);
                if (d < 100) { let push = (100 - d) * 0.5; avoidX -= (obj.x - this.x) * push; avoidY -= (obj.y - this.y) * push; }
            });
            let distToP = Math.sqrt(vecX*vecX + vecY*vecY);
            vecX += avoidX * 5; vecY += avoidY * 5;
            if (distToP < 250) { vecX -= (P.x - this.x); vecY -= (P.y - this.y); }
            game.entities.walls.forEach(w => { let fX = this.x + this.vx * 20; let fY = this.y + this.vy * 20; if (fX > w.x && fX < w.w+w.x && fY > w.y && fY < w.y+w.h) { vecX = -vecX * 2; vecY = vecY + 100; } });
            let desiredAng = Math.atan2(vecY, vecX); let diff = desiredAng - this.a; while(diff <= -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2; this.a += diff * 0.1;
            this.vx += Math.cos(this.a) * CONST.THRUST * this.stats.spd; this.vy += Math.sin(this.a) * CONST.THRUST * this.stats.spd; this.vx *= CONST.FRICTION; this.vy *= CONST.FRICTION;
            let nx = this.x + this.vx; let ny = this.y + this.vy; game.entities.walls.forEach(w => { if(nx+this.r>w.x && nx-this.r<w.x+w.w && ny+this.r>w.y && ny-this.r<w.y+w.h) { this.vx*=-1; this.vy*=-1; nx=this.x; ny=this.y; } }); this.x = nx; this.y = ny;
            if(this.x < 0) this.x = canvas.width; if(this.x > canvas.width) this.x = 0; if(this.y < 0) this.y = canvas.height; if(this.y > canvas.height) this.y = 0;
            
            let t = distToP / 15; let predX = P.x + P.vx * t; let predY = P.y + P.vy * t;
            let aim = Math.atan2(predY - this.y, predX - this.x); 
            let aimDiff = aim - this.a; while(aimDiff <= -Math.PI) aimDiff += Math.PI*2; while(aimDiff > Math.PI) aimDiff -= Math.PI*2; 
            if (Math.abs(aimDiff) < 0.8 && this.cd <= 0) { 
                this.cd = this.stats.fireRate; const noseX = this.x + Math.cos(this.a) * this.r; const noseY = this.y + Math.sin(this.a) * this.r; 
                for(let i=0; i<this.stats.multi; i++) { let ang = this.a + (i - (this.stats.multi-1)/2) * 0.2; let b = new Bullet(noseX, noseY, ang, 15, this.stats.dmg, false); b.color = '#f00'; game.entities.bullets.push(b); } 
            } if(this.cd>0)this.cd--;
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y); 
            if(this.scale < 1) ctx.scale(this.scale, this.scale); 
            ctx.rotate(this.a); ctx.strokeStyle = '#f00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.r, 0); ctx.lineTo(-this.r * 0.6, this.r * 0.7); ctx.lineTo(-this.r * 0.4, 0); ctx.lineTo(-this.r * 0.6, -this.r * 0.7); ctx.closePath(); ctx.stroke(); ctx.fillStyle = '#300'; ctx.fill(); 
            ctx.rotate(-this.a); ctx.fillStyle = '#0f0'; ctx.fillRect(-20, -30, 40, 4); ctx.fillStyle = '#0f0'; ctx.fillRect(-20, -30, 40 * (this.hp/this.maxHp), 4); ctx.font = "10px monospace"; ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.fillText("RIVAL", 0, -35); 
            ctx.restore();
        }
    }

    class Asteroid extends Entity { constructor(x, y, r) { super(x, y, r, '#888'); this.verts = Math.floor(rand(8, 14)); this.offsets = []; for(let i=0; i<this.verts; i++) this.offsets.push(rand(0.7, 1.3)); this.angle = rand(0, Math.PI*2); this.rotSpd = rand(-0.05, 0.05); } update() { this.x += this.vx; this.y += this.vy; if(this.x < -this.r) this.x = canvas.width + this.r; if(this.x > canvas.width + this.r) this.x = -this.r; if(this.y < -this.r) this.y = canvas.height + this.r; if(this.y > canvas.height + this.r) this.y = -this.r; this.angle += this.rotSpd; } draw() { ctx.strokeStyle = '#888'; ctx.lineWidth = 3; ctx.beginPath(); for(let i=0; i<this.verts; i++) { let rad = this.angle + (i / this.verts) * Math.PI * 2; let dist = this.r * this.offsets[i]; ctx.lineTo(this.x + Math.cos(rad) * dist, this.y + Math.sin(rad) * dist); } ctx.closePath(); ctx.stroke(); } }
    
    class Enemy extends Entity {
        constructor(x, y, r, type, bossName) { super(x, y, r, type === 'chaser' ? '#f80' : '#f0f'); this.type = type; this.bossName = bossName || ''; this.angle = 0; this.timer = 0; this.alpha = 1; if (this.type === 'job_boss') this.color = '#f90'; this.isBoss = (type === 'boss' || type === 'job_boss'); this.state = 'normal'; }
        update() {
            if (this.type === 'job_boss') {
                this.timer++;
                if (this.state === 'enter') {
                    this.y += 5; 
                    game.shake = 5; 
                    if (this.timer % 30 === 0) { 
                        ui.screens.boss.innerHTML = `<span style="font-size:40px;color:#fff;text-shadow:0 0 20px #f00">‚ö†Ô∏è JOB APPLICATION INCOMING ‚ö†Ô∏è</span>`;
                        ui.screens.boss.style.display = 'block';
                        setTimeout(() => ui.screens.boss.style.display = 'none', 200);
                    }
                    if (this.y > 300) { 
                        this.state = 'fight';
                        this.y = 300;
                        ui.screens.boss.style.display = 'none';
                    }
                    return;
                }
                this.y = 300 + Math.sin(this.timer*0.05)*20; 
                this.x = canvas.width/2 + Math.sin(this.timer * 0.02) * (canvas.width/2 - 100);
                if (this.timer % 180 === 0 && game.entities.bombs.length < 2) {
                     let targetX = Math.random() * canvas.width;
                     let targetY = canvas.height - 100 - Math.random() * 100; 
                     let b = new Bomb(this.x, this.y, targetX, targetY);
                     game.entities.bombs.push(b);
                }
                let hands = game.entities.enemies.filter(e => e.type === 'job_hand'); 
                this.invulnerable = hands.length > 0;
                if(hands.length === 0) { if(!this.handsDestroyed) { this.handsDestroyed = true; this.handRespawnTimer = 0; } this.handRespawnTimer++; if(this.handRespawnTimer > 60 * 7) { let lh = new Enemy(this.x - 200, this.y + 100, 30, 'job_hand'); lh.hp = 2000; lh.maxHp = 2000; let rh = new Enemy(this.x + 200, this.y + 100, 30, 'job_hand'); rh.hp = 2000; rh.maxHp = 2000; game.entities.enemies.push(lh, rh); this.handsDestroyed = false; } }
                if(hands.length > 0) { 
                    let mode = Math.floor(this.timer / 400) % 2; 
                    hands.forEach((h, i) => { 
                        if (mode === 0) { let ang = this.timer * 0.05 + (i * Math.PI); h.x = this.x + Math.cos(ang) * 250; h.y = this.y + 150 + Math.sin(ang) * 50; } 
                        else { let ang = Math.atan2(game.entities.ship.y - h.y, game.entities.ship.x - h.x); h.x += Math.cos(ang) * 3; h.y += Math.sin(ang) * 3; } 
                        if(this.timer % 40 === 0) game.entities.bullets.push(new Bullet(h.x, h.y, Math.atan2(game.entities.ship.y-h.y, game.entities.ship.x-h.x), 4, 20, false));
                    }); 
                }
                return;
            }
            if (this.isBoss && this.type !== 'job_hand') {
                this.timer++;
                if (this.y < 120 && this.state !== 'charge') { this.y += 2; return; }
                if (this.bossName === "Jax") {
                    this.x += Math.sin(this.timer * 0.03) * 4;
                    if (this.timer % 4 === 0) {
                         let spiralAng = this.timer * 0.1;
                         game.entities.bullets.push(new Bullet(this.x, this.y, spiralAng, 7, 10, false));
                         game.entities.bullets.push(new Bullet(this.x, this.y, spiralAng + Math.PI, 7, 10, false));
                    }
                }
                else if (this.bossName === "Henry") {
                    this.x += Math.sin(this.timer * 0.01) * 2;
                    let cycle = this.timer % 240;
                    if (cycle === 200) { 
                         let ang = Math.atan2(game.entities.ship.y - this.y, game.entities.ship.x - this.x);
                         let b = new Bullet(this.x, this.y, ang, 35, 50, false, 'ball'); 
                         b.r = 20; b.color='#0ff'; game.entities.bullets.push(b);
                         game.shake = 15; sfx.shoot.play();
                    }
                }
                else if (this.bossName === "Larry") {
                    this.x = canvas.width/2 + Math.cos(this.timer * 0.02) * 150;
                    if (this.timer % 60 === 0) {
                        for(let i=0; i<16; i++) {
                            let a = (Math.PI*2*i)/16;
                            game.entities.bullets.push(new Bullet(this.x, this.y, a, 4, 15, false));
                            game.entities.bullets.push(new Bullet(this.x, this.y, a + 0.1, 6, 15, false));
                        }
                    }
                }
                else if (this.bossName === "Bob") {
                    if (this.state === 'normal') {
                        let ang = Math.atan2(game.entities.ship.y - this.y, game.entities.ship.x - this.x);
                        this.x += Math.cos(ang); this.y += Math.sin(ang);
                        if (this.timer % 180 === 0) { this.state = 'charge'; this.chargeTimer = 60; }
                    } else {
                        this.chargeTimer--;
                        if (this.chargeTimer > 30) {
                            let ang = Math.atan2(game.entities.ship.y - this.y, game.entities.ship.x - this.x);
                            this.chargeVX = Math.cos(ang) * 20;
                            this.chargeVY = Math.sin(ang) * 20;
                        } else if (this.chargeTimer > 0) {
                            this.x += this.chargeVX; this.y += this.chargeVY;
                            game.entities.parts.push(new Particle(this.x, this.y, '#ff0'));
                        } else {
                            this.state = 'normal';
                        }
                    }
                    if(this.x < 0) this.x=0; if(this.x > canvas.width) this.x=canvas.width; 
                    if(this.y < 0) this.y=0; if(this.y > canvas.height) this.y=canvas.height;
                }
                else if (this.bossName === "Steve") {
                    if (this.timer % 50 === 0) {
                        game.entities.parts.push(new Particle(this.x, this.y, '#fff'));
                        this.x = Math.random() * canvas.width;
                        this.y = Math.random() * (canvas.height * 0.6);
                        game.shake = 2;
                        for(let k=0; k<8; k++) game.entities.bullets.push(new Bullet(this.x, this.y, Math.random()*Math.PI*2, 6, 12, false));
                    }
                }
            } 
            else if (this.type !== 'job_hand') {
                if(this.x < -this.r) this.x = canvas.width + this.r; if(this.x > canvas.width + this.r) this.x = -this.r; 
                if(this.y < -this.r) this.y = canvas.height + this.r; if(this.y > canvas.height + this.r) this.y = -this.r;
            }
            if(this.type === 'chaser') { 
                let target = game.entities.ship; 
                if (game.entities.rival && !game.entities.rival.dead) {
                    if (dist(this, game.entities.rival) < dist(this, target)) target = game.entities.rival;
                }
                let ang = Math.atan2(target.y - this.y, target.x - this.x); 
                this.x += Math.cos(ang) * 1.5; this.y += Math.sin(ang) * 1.5; this.angle += 0.1; 
            } 
            else if (this.type === 'shooter') { 
                this.x += this.vx; this.y += this.vy; 
                if(this.x < this.r || this.x > canvas.width - this.r) this.vx *= -1; 
                if(this.y < this.r || this.y > canvas.height - this.r) this.vy *= -1; 
                if (Math.random() < 0.015) { 
                    let target = game.entities.ship;
                    if (game.entities.rival && !game.entities.rival.dead && dist(this, game.entities.rival) < dist(this, target)) {
                        target = game.entities.rival;
                    }
                    let ang = Math.atan2(target.y - this.y, target.x - this.x); 
                    game.entities.bullets.push(new Bullet(this.x, this.y, ang, 5, 10, false)); 
                } 
            } 
            else if (this.type === 'minion') { this.angle += 0.05; if(this.parent && !this.parent.dead) { this.x = this.parent.x + Math.cos(this.angle) * this.orbitDist; this.y = this.parent.y + Math.sin(this.angle) * this.orbitDist; if(Math.random() < 0.01) { let t = game.entities.ship; let ang = Math.atan2(t.y - this.y, t.x - this.x); game.entities.bullets.push(new Bullet(this.x, this.y, ang, 3, 5, false)); } } else { this.dead = true; } }
            else { if(this.updateFn) this.updateFn(); else { this.x += this.vx; this.y += this.vy; } }
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y); if (this.alpha < 1) ctx.globalAlpha = this.alpha;
            if (this.type === 'job_boss') { 
                if(images.jobBoss.complete) ctx.drawImage(images.jobBoss, -160, -240, 320, 480); 
                else { ctx.fillStyle = '#f90'; ctx.fillRect(-160, -240, 320, 480); } 
                if (this.invulnerable) { 
                    ctx.rotate(this.timer * 0.02);
                    let grad = ctx.createRadialGradient(0, 0, 150, 0, 0, 220);
                    grad.addColorStop(0, "rgba(0, 255, 255, 0)");
                    grad.addColorStop(0.5, "rgba(0, 255, 255, 0.1)");
                    grad.addColorStop(1, "rgba(0, 255, 255, 0.6)");
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    for(let i=0; i<6; i++) {
                        let a = (Math.PI*2*i)/6;
                        ctx.lineTo(Math.cos(a)*220, Math.sin(a)*220);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#0ff'; ctx.lineWidth = 3; ctx.stroke();
                } 
            } 
            else if (this.type === 'job_hand') { ctx.fillStyle = '#ddd'; ctx.strokeStyle = '#555'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-15, 20); ctx.lineTo(-20, -20); ctx.lineTo(20, -20); ctx.lineTo(15, 20); ctx.closePath(); ctx.fill(); ctx.stroke(); for(let i=0; i<3; i++) { ctx.fillRect(-15 + i*12, 20, 8, 20); ctx.strokeRect(-15 + i*12, 20, 8, 20); } ctx.fillRect(20, 0, 10, 20); ctx.strokeRect(20, 0, 10, 20); ctx.fillStyle = 'red'; ctx.fillRect(-25, -40, 50, 5); ctx.fillStyle = '#0f0'; ctx.fillRect(-25, -40, 50 * (this.hp / this.maxHp), 5); } 
            else if (this.type === 'boss') { 
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                if (this.bossName === "Jax") { let ang = this.timer * 0.2; ctx.rotate(ang); ctx.fillStyle = '#333'; ctx.fillRect(-25, -25, 50, 50); ctx.fillStyle = this.color; ctx.fillRect(0, -10, 40, 8); ctx.fillRect(0, 2, 40, 8); ctx.fillRect(-40, -10, 40, 8); ctx.fillRect(-40, 2, 40, 8); }
                else if (this.bossName === "Henry") { ctx.rotate(0); ctx.fillStyle = '#033'; ctx.strokeStyle = this.color; ctx.lineWidth = 4; ctx.fillRect(-30, -30, 60, 60); ctx.beginPath(); ctx.arc(0,0, 10, 0, 7); ctx.fillStyle='#f00'; ctx.fill(); }
                else if (this.bossName === "Larry") { let scale = 1 + Math.sin(this.timer * 0.1) * 0.2; ctx.scale(scale, scale); ctx.fillStyle = '#404'; ctx.strokeStyle = '#f0f'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0,0,35,0,7); ctx.fill(); ctx.stroke(); }
                else if (this.bossName === "Bob") { ctx.fillStyle = this.state==='charge'?'#f00':'#ff0'; ctx.beginPath(); ctx.moveTo(40, 0); ctx.lineTo(-30, 30); ctx.lineTo(-30, -30); ctx.fill(); }
                else if (this.bossName === "Steve") { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; for(let i=0; i<5; i++) { let offX = Math.random()*10 - 5; let offY = Math.random()*10 - 5; ctx.strokeRect(-30 + offX, -30 + offY, 60, 60); } }
                ctx.shadowBlur = 0; ctx.setTransform(1, 0, 0, 1, this.x, this.y); 
                
                // Henry Laser Sight
                if (this.bossName === "Henry" && this.timer % 240 >= 180 && this.timer % 240 < 200) {
                    let ang = Math.atan2(game.entities.ship.y - this.y, game.entities.ship.x - this.x);
                    ctx.strokeStyle = `rgba(255, 0, 0, 0.8)`; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(ang)*1000, Math.sin(ang)*1000); ctx.stroke();
                }

                ctx.fillStyle = 'red'; ctx.fillRect(-40, -this.r - 20, 80, 8); ctx.fillStyle = '#0f0'; ctx.fillRect(-40, -this.r - 20, 80 * (this.hp / this.maxHp), 8); ctx.fillStyle = '#fff'; ctx.font = "12px monospace"; ctx.textAlign='center'; ctx.fillText(this.name, 0, -this.r - 25);
            } 
            else if (this.type === 'chaser') { ctx.rotate(this.angle); ctx.strokeStyle = '#f80'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(this.r, 0); ctx.lineTo(0, this.r); ctx.lineTo(-this.r, 0); ctx.lineTo(0, -this.r); ctx.closePath(); ctx.stroke(); } 
            else if (this.type === 'minion') { ctx.fillStyle = '#f0f'; ctx.beginPath(); ctx.arc(0,0,8,0,7); ctx.fill(); }
            else { let ang = Math.atan2(game.entities.ship.y - this.y, game.entities.ship.x - this.x); ctx.rotate(ang); ctx.strokeStyle = '#0f0'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(this.r, 0); ctx.lineTo(-this.r, this.r*0.8); ctx.lineTo(-this.r*0.5, 0); ctx.lineTo(-this.r, -this.r*0.8); ctx.closePath(); ctx.stroke(); } 
            ctx.restore();
        }
    }
    class Bomb extends Entity { 
        constructor(x, y, tx, ty) { super(x, y, 10, '#f00'); this.timer = 30; this.defuse = 0; this.radius = 120; this.targetX = tx; this.targetY = ty; this.moving = true; this.startX = x; this.startY = y; this.moveTime = 0; } 
        update() { 
            if (this.moving) { 
                this.moveTime += 0.02; 
                this.x = this.startX + (this.targetX - this.startX) * this.moveTime; 
                this.y = this.startY + (this.targetY - this.startY) * this.moveTime; 
                let arcH = -300 * Math.sin(this.moveTime * Math.PI); // Higher Arc
                this.y += arcH; 
                this.r = 15 + Math.abs(arcH * 0.05); 
                if (this.moveTime >= 1) { this.moving = false; this.r = 25; } 
                return; 
            } 
            let d = dist(this, game.entities.ship); 
            if (d < this.radius) { 
                this.defuse += 1/60; 
                if (this.defuse >= 5) { this.dead = true; game.addXP(1000); aiCore.log("BOMB DEFUSED!"); } 
            } else { 
                this.timer -= 1/60; 
                if (this.timer <= 0) { sfx.pop.play(); game.lastKiller='bomb'; game.gameOver(); } 
            } 
        } 
        draw() { 
            if(this.moving) { ctx.fillStyle = '#f50'; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, 7); ctx.fill(); return; } 
            ctx.strokeStyle = '#0f0'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, 7); ctx.stroke(); 
            ctx.fillStyle = '#f00'; ctx.font = "24px Arial"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("üí£", this.x, this.y); 
            ctx.fillStyle = '#444'; ctx.fillRect(this.x - 30, this.y - 30, 60, 8); 
            ctx.fillStyle = '#0f0'; ctx.fillRect(this.x - 30, this.y - 30, 60 * (this.defuse / 5), 8); 
            ctx.fillStyle = '#fff'; ctx.font = "14px monospace"; ctx.fillText(this.timer.toFixed(1) + "s", this.x, this.y + 35); 
        } 
    }
    class Bullet extends Entity { 
        constructor(x, y, a, spd, dmg, isPlayer, type='std') { super(x, y, type==='ball'?10:4, isPlayer ? '#0ff' : '#f00'); this.vx = Math.cos(a) * spd; this.vy = Math.sin(a) * spd; this.dmg = dmg; this.isPlayer = isPlayer; this.life = 120; this.type = type; this.homing = false; } 
        update() { if (this.homing && game.entities.ship && !this.isPlayer) { let target = game.entities.ship; let angle = Math.atan2(target.y - this.y, target.x - this.x); let currentAngle = Math.atan2(this.vy, this.vx); let diff = angle - currentAngle; while(diff <= -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2; currentAngle += (diff > 0 ? 0.05 : -0.05); let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy); this.vx = Math.cos(currentAngle) * speed; this.vy = Math.sin(currentAngle) * speed; } if(this.type === 'ball') { this.x += this.vx; this.y += this.vy; if(this.x < 0 || this.x > canvas.width) this.vx *= -1; if(this.y < 0 || this.y > canvas.height) this.vy *= -1; } else if (this.type === 'beam') { this.life -= 1; } else { super.update(); } game.entities.walls.forEach(w => { if(this.x > w.x && this.x < w.x+w.w && this.y > w.y && this.y < w.y+w.h) this.dead = true; }); this.life--; if(this.life <= 0) this.dead = true; } 
        draw() { if(this.type === 'beam') { ctx.fillStyle = `rgba(255,50,0,${Math.random()*0.5 + 0.5})`; let w = 60 + Math.sin(Date.now()/50)*10; ctx.fillRect(this.x - w/2, 0, w, canvas.height); ctx.fillStyle = '#fff'; ctx.fillRect(this.x - 5, 0, 10, canvas.height); return; } ctx.fillStyle = this.color; ctx.beginPath(); if(this.type === 'ball') ctx.arc(this.x, this.y, this.r, 0, 7); else { let a = Math.atan2(this.vy, this.vx); ctx.ellipse(this.x, this.y, this.r*2, this.r, a, 0, Math.PI*2); } ctx.fill(); } 
    }
    class Particle extends Entity { constructor(x, y, col) { super(x, y, rand(1,3), col); let a = rand(0, 7); let s = rand(1, 5); this.vx = Math.cos(a)*s; this.vy = Math.sin(a)*s; this.life = 30; } update() { this.x += this.vx; this.y += this.vy; this.life--; if(this.life<=0) this.dead=true; } draw() { ctx.globalAlpha = this.life/30; super.draw(); ctx.globalAlpha = 1; } }
    class BlackHole extends Entity { constructor(x, y) { super(x, y, 5, '#000'); this.pullRange = 300; this.force = 0.3; this.timer = 0; this.life = 600; } update() { this.timer++; this.life--; if(this.life <= 0) { this.dead = true; game.entities.parts.push(new Particle(this.x, this.y, '#80f')); return; } let d = dist(this, game.entities.ship); if (d < this.pullRange) { let angle = Math.atan2(this.y - game.entities.ship.y, this.x - game.entities.ship.x); let pullStr = (1 - d/this.pullRange) * this.force; game.entities.ship.vx += Math.cos(angle) * pullStr; game.entities.ship.vy += Math.sin(angle) * pullStr; } if (Math.random() < 0.2) { let ang = Math.random() * Math.PI * 2; let r = this.pullRange * (this.life/600); game.entities.parts.push(new Particle(this.x + Math.cos(ang)*r, this.y + Math.sin(ang)*r, '#80f')); } } draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.timer * 0.1); let scale = Math.min(1, this.life / 60); ctx.scale(scale, scale); let grad = ctx.createRadialGradient(0,0,10, 0,0,60); grad.addColorStop(0, '#000'); grad.addColorStop(0.5, '#408'); grad.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0,0,60,0,7); ctx.fill(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0,0,15,0,7); ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(0,0,15,0,7); ctx.stroke(); ctx.restore(); } }

    const game = {
        state: 'init', mode: 'standard', level: 1, xp: 0, xpReq: 100, score: 0, loopId: null, xpMult: 1,
        spawnQueue: [], lastKiller: null, shake: 0, playStartTime: 0, levelTimer: 0, rivalActive: false,
        cutsceneState: null, cutsceneTimer: 0,
        entities: { ship: null, asteroids: [], enemies: [], bullets: [], parts: [], walls: [], ghosts: [], bombs: [], blackholes: [], stars: [], rival: null },
        bossNames: ["Jax", "Henry", "Larry", "Bob", "Steve"],

        initDemo() { if (this.loopId) cancelAnimationFrame(this.loopId); this.resetVars(true); aiCore.init(); this.state = 'menu'; this.spawnWave(); ui.hudMain.style.opacity = 0.5; ui.screens.pause.classList.add('hidden'); ui.screens.start.classList.remove('hidden'); ui.watchOverlay.style.display = 'none'; ui.watchBtn.style.display = 'flex'; loop(); MusicSystem.playMenu(); },
        toggleWatchMode(active) { if (active) { ui.screens.start.classList.add('hidden'); ui.hudMain.style.opacity = 0.2; ui.watchOverlay.style.display = 'block'; ui.watchBtn.style.display = 'none'; } else { ui.screens.start.classList.remove('hidden'); ui.hudMain.style.opacity = 0.5; ui.watchOverlay.style.display = 'none'; ui.watchBtn.style.display = 'flex'; } },
        startGameplay() { this.resetVars(true); this.state = 'play'; this.playStartTime = Date.now(); ui.hudMain.style.opacity = 1; ui.screens.start.classList.add('hidden'); ui.watchBtn.style.display = 'none'; MusicSystem.playNormal(); },
        togglePause() { 
            if(this.state === 'play') { 
                this.state = 'paused'; 
                ui.screens.pause.classList.remove('hidden'); 
                MusicSystem.togglePause(true); 
                const diff = Date.now() - this.playStartTime; const secs = Math.floor(diff / 1000); const m = Math.floor(secs / 60).toString().padStart(2,'0'); const s = (secs % 60).toString().padStart(2,'0'); ui.pauseTime.innerText = `Run Time: ${m}:${s}`; 
            } else if(this.state === 'paused') { 
                this.state = 'play'; 
                ui.screens.pause.classList.add('hidden'); 
                MusicSystem.togglePause(false); 
            } 
        },
        restartRun() { ui.screens.pause.classList.add('hidden'); this.startGameplay(); },
        resetToMenu() { ui.screens.over.classList.add('hidden'); ui.screens.pause.classList.add('hidden'); this.initDemo(); },
        resetVars(full=true) { if(full) { this.level = 1; this.xp = 0; this.score = 0; this.xpReq = 100; this.xpMult = 1; } this.mode = 'standard'; this.spawnQueue = []; this.lastKiller = null; this.levelTimer = 0; this.rivalActive = false; this.cutsceneState = null; this.entities = { ship: new Ship(), asteroids: [], enemies: [], bullets: [], parts: [], walls: [], ghosts: [], bombs: [], blackholes: [], stars: [], rival: null }; for(let i=0; i<100; i++) this.entities.stars.push(new Star()); this.updateHUD(); aiCore.updateUI(); },

        startLevel20() {
            this.entities.enemies = []; 
            this.entities.asteroids = []; 
            this.entities.walls = []; 
            this.entities.bullets = []; 
            
            this.entities.rival = new Rival(false); 
            this.entities.rival.x = canvas.width + 100; 
            this.entities.rival.y = canvas.height / 2;
            this.entities.rival.scale = 1; 
            this.rivalActive = true;

            ui.duel.style.display = 'block';
            setTimeout(() => ui.duel.style.display = 'none', 2000);
            
            // Force Rival music on slight delay to ensure no overlap
            setTimeout(() => { MusicSystem.playRival(); }, 100);
        },

        updateHUD() {
            if (!this.entities.ship) return; const hpPct = Math.max(0, (this.entities.ship.hp / this.entities.ship.maxHp) * 100); const color = hpPct > 50 ? '#0f0' : (hpPct > 25 ? '#ff0' : '#f00'); ui.hpPie.style.background = `conic-gradient(${color} 0%, ${color} ${hpPct}%, #222 ${hpPct}%, #222 100%)`; ui.hpPie.style.boxShadow = `0 0 10px ${color}`; ui.hp.innerText = Math.ceil(this.entities.ship.hp); ui.lvl.innerText = this.level; ui.score.innerText = Math.floor(this.score); let pct = (this.xp / this.xpReq) * 100; ui.progBar.style.width = pct + '%'; ui.progText.innerText = `Wave Progress ${Math.floor(pct)}%`;
            if (this.entities.enemies.some(e => e.type === 'job_boss')) ui.mode.innerText = "BOSS: JOB APPLICATION"; else if (this.level === 20) ui.mode.innerText = "BOSS: THE RIVAL"; else ui.mode.innerText = "";
            aiCore.updateUI();
        },

        addXP(amt) {
            if (this.state === 'menu') return; const bossActive = this.entities.enemies.some(e => e.type === 'boss' || e.type === 'job_boss') || (this.level === 20 && this.rivalActive); let gained = amt * this.xpMult;
            if (bossActive) { this.xp += gained; this.score += gained; if (this.xp >= this.xpReq) this.xp = this.xpReq - 1; } 
            else { 
                this.xp += gained; 
                this.score += gained; 
                if (this.xp >= this.xpReq) { 
                    this.xp = 0; 
                    this.level++; 
                    this.xpReq = Math.floor(this.xpReq * 1.2 + 50); 
                    if (this.level === 20) this.startLevel20(); 
                    else if (this.level % 100 === 0) this.spawnJobBoss(); 
                    else if (this.level % 5 === 0) this.spawnBoss(); 
                    else this.showUpgrades(); 
                } 
            }
            this.updateHUD();
        },

        spawnBoss() {
            const name = game.bossNames[(Math.floor(game.level/5) - 1) % game.bossNames.length];
            ui.screens.boss.innerHTML = `‚ö†Ô∏è BOSS INCOMING ‚ö†Ô∏è<br><span style="font-size:20px;color:#fff">${name}</span>`;
            let b = new Enemy(canvas.width/2, -100, 40, 'boss', name); b.hp = 1000 * Math.pow(1.2, this.level); b.maxHp = b.hp; b.isBoss = true; b.name = name; b.timer = 0;
            if (name === 'Jax') b.color = '#f00'; else if (name === 'Henry') b.color = '#00f'; else if (name === 'Larry') b.color = '#f0f'; else if (name === 'Bob') b.color = '#ff0'; else b.color = '#fff';
            ui.screens.boss.style.display = 'block'; setTimeout(() => { ui.screens.boss.style.display = 'none'; this.entities.enemies.push(b); }, 3000);
        },

        spawnJobBoss() {
            this.entities.enemies = []; this.entities.asteroids = []; MusicSystem.playJob();
            let b = new Enemy(canvas.width/2, -200, 80, 'job_boss', 'JOB APPLICATION'); 
            b.hp = 10000 * Math.pow(1.1, this.level); b.maxHp = b.hp; b.isBoss = true; b.name = "JOB APPLICATION"; b.timer = 0; b.invulnerable = true; b.handRespawnTimer = 0; b.handsDestroyed = false; b.state = 'enter'; 
            let lh = new Enemy(b.x-200, b.y+100, 30, 'job_hand'); lh.hp = 2000; lh.maxHp=2000; let rh = new Enemy(b.x+200, b.y+100, 30, 'job_hand'); rh.hp = 2000; rh.maxHp=2000; this.entities.enemies.push(lh, rh);
            this.entities.enemies.push(b);
        },

        spawnWave() {
            if (!debug.spawningEnabled) return;
            if (this.level === 20) return; // Don't spawn during Rival level
            if (this.level % 5 !== 0 && this.level > 19 && !this.rivalActive && Math.random() < 0.05) { 
                this.entities.rival = new Rival(true); 
                this.rivalActive = true; 
                MusicSystem.playRival(); // Use optimized music call
                ui.screens.boss.innerHTML = `<span style="color:#f00">RIVAL DETECTED</span>`; ui.screens.boss.style.display='block'; setTimeout(()=>ui.screens.boss.style.display='none', 2000); 
            }
            let count = (this.state === 'menu') ? 5 : 3 + Math.floor(this.level * 1.2);
            for(let i=0; i<count; i++) { let r = rand(20, 45), a = new Asteroid(rand(0,canvas.width), rand(0,canvas.height), r); a.vx = rand(-2,2); a.vy = rand(-2,2); a.hp = 20 * (1 + game.level * 0.1); if(dist(a, game.entities.ship) > 200) game.entities.asteroids.push(a); }
            if(this.level > 1 || this.state === 'menu') { let eCount = Math.floor(count / 2); for(let i=0; i<eCount; i++) { let type = Math.random() > 0.5 ? 'chaser' : 'shooter'; let e = new Enemy(rand(0,canvas.width), rand(0,canvas.height), 15, type); e.hp = 30; e.speed = 3; e.vx = rand(-2, 2); e.vy = rand(-2, 2); if(dist(e, game.entities.ship) > 200) game.entities.enemies.push(e); } }
            if (this.level > 3 && Math.random() < 0.2) game.entities.blackholes.push(new BlackHole(rand(100, canvas.width-100), rand(100, canvas.height-100)));
        },

        showUpgrades() {
            const defs = [ { id: 'dmg', name: "XP Boost", val: 25, fn: (s, v)=>game.xpMult=(game.xpMult||1)+(v/100) }, { id: 'dmg', name: "Extra Damage", val: 20, fn: (s, v)=>s.dmg*=(1+v/100) }, { id: 'hp', name: "Extra Health", val: 20, fn: (s, v)=>{ s.maxHp*=(1+v/100); game.entities.ship.maxHp=s.maxHp; game.entities.ship.hp+=v; } }, { id: 'spd', name: "Thrusters", val: 10, fn: (s, v)=>s.spd*=(1+v/100) }, { id: 'rate', name: "Fire Rate", val: 15, fn: (s, v)=>s.fireRate*=(1-v/100) }, { id: 'multi', name: "Split Shot", val: 1, fn: (s, v)=>s.multi+=v }, { id: 'heal', name: "Repair", val: 50, fn: (s, v)=>game.entities.ship.hp=Math.min(game.entities.ship.maxHp, game.entities.ship.hp+game.entities.ship.maxHp*(v/100)) } ];
            const rarity = [{ name: 'common', color: 'green', chance: 60, mult: 1 }, { name: 'uncommon', color: 'blue', chance: 30, mult: 1.5 }, { name: 'rare', color: 'purple', chance: 9, mult: 2 }, { name: 'legendary', color: 'red', chance: 1, mult: 3 }];
            const getRarity = () => { let r=Math.random()*100, sum=0; for(let i=0; i<rarity.length; i++) { sum+=rarity[i].chance; if(r<=sum) return rarity[i]; } return rarity[0]; };
            if (debug.autoPilot && this.state === 'play') { const hpPct = this.entities.ship.hp / this.entities.ship.maxHp; let choice = (hpPct<0.6?defs.find(d=>d.id==='heal'||d.id==='hp'):null) || defs[Math.floor(Math.random()*defs.length)]; let rar=getRarity(); choice.fn(this.entities.ship.stats, Math.floor(choice.val*rar.mult)); this.spawnWave(); return; }
            this.state = 'paused'; const list = document.getElementById('upgrade-list'); list.innerHTML = '';
            for(let i=0; i<4; i++) { const type=defs[Math.floor(Math.random()*defs.length)], rar=getRarity(), val=Math.floor(type.val*rar.mult); let d=document.createElement('div'); d.className=`upgrade-card rarity-${rar.name}`; d.innerHTML=`<div class="u-title" style="color:${rar.color}">${type.name}</div><div class="u-desc">(+${val}${type.id==='multi'?'':'%'})</div>`; d.onclick=()=>{ type.fn(this.entities.ship.stats, val); ui.screens.upgrade.classList.add('hidden'); this.state='play'; this.spawnWave(); }; list.appendChild(d); } ui.screens.upgrade.classList.remove('hidden');
        },

        gameOver() {
            if (this.state === 'menu') { this.entities.ship = new Ship(); return; }
            if (debug.autoPilot && this.state === 'play') { aiCore.recordRun(this.level, this.lastKiller, this.score); this.startGameplay(); return; }
            this.state = 'over'; if (this.loopId) { cancelAnimationFrame(this.loopId); this.loopId = null; } sfx.bruh.currentTime = 0; sfx.bruh.play().catch(e=>{}); MusicSystem.stopAll();
            document.getElementById('final-score').innerText = Math.floor(this.score); document.getElementById('final-level').innerText = this.level;
            let title = "You Suck :)"; if (this.entities.enemies.some(e => e.type === 'job_boss')) title = "You got Employed... :(";
            document.getElementById('game-over-title').innerText = title; ui.screens.over.classList.remove('hidden'); aiCore.recordRun(this.level, this.lastKiller, this.score);
        }
    };

    const debug = { 
        active: false, godMode: false, instaKill: false, autoPilot: false, spawningEnabled: true,
        toggle() { this.active = !this.active; ui.debug.style.display = this.active ? 'block' : 'none'; }, 
        close() { this.toggle(); }, 
        toggleSidebar() { 
            const w=document.getElementById('ai-wrapper'), open=w.style.width==='380px'; 
            aiCore.panelOpen=!open; w.style.width=open?'0px':'380px'; 
        },
        toggleRivalSidebar() { 
            const w=document.getElementById('rival-wrapper'), open=w.style.width==='380px'; 
            rivalBrain.panelOpen=!open; w.style.width=open?'0px':'380px'; 
        },
        toggleAuto() { this.autoPilot = !this.autoPilot; document.getElementById('dbg-auto').innerText = this.autoPilot ? "ON" : "OFF"; document.getElementById('dbg-auto').style.color = this.autoPilot ? "#0f0" : "#fff"; },
        toggleSpawning() { this.spawningEnabled = !this.spawningEnabled; document.getElementById('dbg-spawn').innerText = this.spawningEnabled ? "ON" : "OFF"; document.getElementById('dbg-spawn').style.color = this.spawningEnabled ? "#0f0" : "#f00"; },
        toggleMusic() { let m = MusicSystem.toggleMute(); document.getElementById('dbg-music').innerText = m ? "OFF" : "ON"; },
        toggleGod() { this.godMode = !this.godMode; document.getElementById('dbg-god').innerText = this.godMode ? "ON" : "OFF"; document.getElementById('dbg-god').style.color = this.godMode ? "#0f0" : "#fff"; }, 
        toggleInsta() { this.instaKill = !this.instaKill; document.getElementById('dbg-insta').innerText = this.instaKill ? "ON" : "OFF"; document.getElementById('dbg-insta').style.color = this.instaKill ? "#0f0" : "#fff"; }, 
        skipLevel() { game.xp = game.xpReq; game.addXP(0); this.close(); }, 
        skipTo20() { 
            // FORCE LEVEL 19 and TRIGGER XP to ensure natural flow
            game.level = 19; 
            game.xp = game.xpReq; // Fill bar
            game.addXP(0); // Trigger level up
            this.close(); 
        },
        forceRival() { game.level = 21; game.rivalActive = false; game.entities.rival = null; game.spawnWave(); game.entities.rival = new Rival(true); game.rivalActive = true; MusicSystem.playRival(); this.close(); },
        killAll() { game.entities.enemies.forEach(e => e.hp = 0); game.entities.asteroids.forEach(a => a.dead = true); if(game.entities.rival) game.entities.rival.hp = 1; this.close(); }, 
        skipToBoss() { let nextBoss = Math.ceil((game.level + 0.1) / 5) * 5; game.level = nextBoss; game.entities.enemies = []; game.entities.asteroids = []; game.spawnBoss(); game.updateHUD(); this.close(); }, 
        skipToJob() { game.level = 100; game.entities.enemies = []; game.entities.asteroids = []; game.spawnJobBoss(); game.updateHUD(); this.close(); } 
    };

    window.onload = () => { canvas.width = document.getElementById('game-container').clientWidth; canvas.height = window.innerHeight; window.game = game; window.debug = debug; window.aiCore = aiCore; game.initDemo(); }
    window.onresize = () => { 
        const w = document.getElementById('game-container').clientWidth; 
        if (w > 0) canvas.width = w; 
        canvas.height = window.innerHeight; 
    }
    window.fakeAd = function() { try{if(sfx.sike){sfx.sike.currentTime=0;sfx.sike.play().catch(e=>{});}const btn=document.querySelector('.ad-btn');if(btn){const old=btn.innerHTML;btn.innerHTML="<span style='font-size:20px'>SIKE! LOL</span>";btn.style.background="#f00";btn.style.color="#fff";setTimeout(()=>{btn.innerHTML=old;btn.style.background="";btn.style.color="#f90";},1500);}}catch(e){} };

    function loop() {
        try {
            game.loopId = requestAnimationFrame(loop);
            
            const cw = document.getElementById('game-container').clientWidth;
            const ch = document.getElementById('game-container').clientHeight;
            if (canvas.width !== cw || canvas.height !== ch) {
                 canvas.width = cw;
                 canvas.height = ch;
            }

            if(game.state !== 'play' && game.state !== 'menu') return;
            if(game.entities.ship) rivalBrain.observe(game.entities.ship);

            // --- STANDARD GAME LOOP ---
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            if(game.shake > 0) { let m = game.shake; ctx.translate(Math.random()*m - m/2, Math.random()*m - m/2); game.shake *= 0.9; if(game.shake<0.5) game.shake=0; }
            const S = game.entities.ship; if(!S) { ctx.restore(); return; }
            
            if (S.x < S.r) S.x = S.r;
            if (S.x > canvas.width - S.r) S.x = canvas.width - S.r;

            game.entities.stars.forEach(s => { s.update(S.vx, S.vy); s.draw(); });
            game.entities.walls.forEach(w => { w.update(); w.draw(); });

            S.update(game.mode);
            if (game.entities.rival) { const R = game.entities.rival; if (!R.dead) { R.update(); R.draw(); if(checkCol(S, R) && S.invuln <= 0 && !R.fleeing && !debug.godMode) { S.hp -= 20; S.invuln = 60; game.shake=10; } } else { game.entities.rival = null; } }

            game.entities.blackholes.forEach(b => { b.update(); b.draw(); }); game.entities.blackholes = game.entities.blackholes.filter(b => !b.dead);
            game.entities.bombs.forEach(b => { b.update(); b.draw(); }); game.entities.bombs = game.entities.bombs.filter(b => !b.dead);
            game.entities.asteroids.forEach(a => { a.update(); a.draw(); game.entities.asteroids.forEach(a2 => { if(a!==a2 && checkCol(a, a2)) { let dx = a2.x - a.x, dy = a2.y - a.y; a.vx -= dx*0.01; a.vy -= dy*0.01; } }); if(checkCol(S, a) && S.invuln <= 0 && !debug.godMode) { S.hp -= 10; S.invuln = 30; S.vx -= a.vx*2; S.vy -= a.vy*2; game.shake = 10; game.updateHUD(); aiCore.recordDamage('contact'); if(S.hp<=0) { game.lastKiller='asteroid'; game.gameOver(); return; } } });
            game.entities.enemies.forEach(e => { e.update(); e.draw(); if(checkCol(S, e) && S.invuln <= 0 && !debug.godMode && e.type !== 'minion') { S.hp -= 20; S.invuln = 60; game.shake = 10; game.updateHUD(); aiCore.recordDamage('contact'); if(S.hp<=0) { game.lastKiller=e.type; game.gameOver(); return; } } });
            game.entities.bullets.forEach(b => { b.update(); b.draw(); game.entities.asteroids.forEach(a => { if(checkCol(b, a)) { b.dead = true; a.dead = true; game.addXP(10); aiCore.recordKill('asteroid'); game.entities.parts.push(new Particle(a.x, a.y, '#aaa')); game.shake = 5; } }); if(b.isPlayer) { if (game.entities.rival && checkCol(b, game.entities.rival) && game.entities.rival.aiState === 'fight') { b.dead = true; game.entities.rival.hp -= b.dmg * 0.2; /* RIVAL RESISTANCE */ game.entities.parts.push(new Particle(game.entities.rival.x, game.entities.rival.y, '#f00')); } game.entities.enemies.forEach(e => { if(checkCol(b, e) && e.type !== 'brick') { if(e.invulnerable) { game.entities.parts.push(new Particle(e.x, e.y, '#0ff')); b.dead = true; return; } if(e.alpha < 1) return; b.dead = true; e.hp -= debug.instaKill ? 99999 : b.dmg; game.entities.parts.push(new Particle(e.x, e.y, e.color)); if(e.hp <= 0) { e.dead = true; game.shake = 5; game.addXP(e.isBoss ? 500 : 50); aiCore.recordKill(e.isBoss ? 'boss' : 'enemy'); if(S.stats.vamp > 0) { S.hp = Math.min(S.maxHp, S.hp + S.stats.vamp); game.updateHUD(); } } } }); } else { if (checkCol(b, S) && S.invuln <= 0 && !debug.godMode) { if (b.type === 'beam') { S.hp -= 1; } else { b.dead = true; S.hp -= b.dmg; } game.shake = 5; game.updateHUD(); aiCore.recordDamage('bullet'); if(S.hp<=0) { game.lastKiller='bullet'; game.gameOver(); return; } } if (game.entities.rival && checkCol(b, game.entities.rival) && !b.isPlayer && game.level > 20) { b.dead = true; game.entities.rival.hp -= 10; } } });
            game.entities.asteroids = game.entities.asteroids.filter(e => !e.dead); game.entities.enemies = game.entities.enemies.filter(e => !e.dead); game.entities.bullets = game.entities.bullets.filter(e => !e.dead);
            if(game.mode === 'standard' && game.entities.asteroids.length === 0 && game.entities.enemies.length === 0 && game.spawnQueue.length === 0 && !game.entities.rival && game.level !== 20) game.spawnWave();
            game.entities.parts.forEach(p => { p.update(); p.draw(); }); game.entities.parts = game.entities.parts.filter(p => !p.dead);
            S.draw(); if(S.hp <= 0) game.gameOver(); ctx.restore();
        } catch (e) {
            console.error("Game Loop Crash:", e);
            if (game.state === 'play') {
                alert("Critical Failure detected. Rebooting simulation...");
                game.resetToMenu();
            }
        }
    }
})();
</script>
</body>
</html>